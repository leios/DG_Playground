var documenterSearchIndex = {"docs":
[{"location":"dg_methods/#Discontinuous-Galerkin-1","page":"Discontinuous Galerkin","title":"Discontinuous Galerkin","text":"","category":"section"},{"location":"dg_methods/#","page":"Discontinuous Galerkin","title":"Discontinuous Galerkin","text":"In CLIMA the Discontinuous Galerkin method serves as our spatial discretization method. It may be thought of as a combination of spectral methods and finite volume methods and serves as a higher-order generalization of a finite volume method.","category":"page"},{"location":"convective_adjustment/#Convective-Adjustment-1","page":"Convective Adjustment","title":"Convective Adjustment","text":"","category":"section"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"Convective adjustment is a simple parameterization that attempts the capture the effect of mixing due to convection. Physically this occurs because dense water parcels tend to sink and and light water parcels tend to rise","category":"page"},{"location":"convective_adjustment/#Mathematical-Form-1","page":"Convective Adjustment","title":"Mathematical Form","text":"","category":"section"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"Typically the effect of convective adjustment is captured via a nonlinear diffusivity such as","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\nkappa(rho) = begincases\nkappa_1  text if text   partial_z rho  0\n\nkappa_2  text otherwise\nendcases\nendaligned","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"where kappa_1 gg kappa_2, and z is aligned with the direction of gravity. Thinking of $ \\rho $ as density, a simple parameterization of convection is of the form","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\npartial_t rho = nabla cdot left kappa(rho) nabla rho right\nendaligned","category":"page"},{"location":"convective_adjustment/#Typical-Time-Discretization-1","page":"Convective Adjustment","title":"Typical Time-Discretization","text":"","category":"section"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"A typical time-discretization would be","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\nrho^n+1 - Delta t partial_z left kappa(rho^n) partial_z rho^n+1 right = rho^n + Delta t left( f^n + nabla^H cdot left kappa(rho^n) nabla^H rho^n right right)\nendaligned","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"where the forcing function f^n comes from boundary condition and we have split the gradient operator into the vertically aligned component z and the other (horizontal) directions.","category":"page"},{"location":"convective_adjustment/#Simplification-1","page":"Convective Adjustment","title":"Simplification","text":"","category":"section"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"There are a wide variety of functional forms that kappa(rho^n) can take on, but typically it is similar to","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"beginaligned\n    kappa(rho^n) approx\n    begincases\n    kappa_1  text if  z  h \n    kappa_2  text if  z leq h\n    endcases\nendaligned","category":"page"},{"location":"convective_adjustment/#","page":"Convective Adjustment","title":"Convective Adjustment","text":"where z in 0 L and h can take on all values between 0 L. The reason why there is usually just one place that kappa changes values of diffusivity has to do typical physical scenarios that arise in the ocean / atmosphere. The ocean interior is stably stratified as there is no appreciably strong convection. In the ocean cooling comes from the surface of the ocean and leads to mixing that starts in the upper ocean and progresses towards the ocean abyss. The solution to linear systems of this form (when Delta t becomes large), is essentially constant in the region of high diffusivity.","category":"page"},{"location":"function_index/#List-of-functions-in-DG_Playground-module-1","page":"Function Index","title":"List of functions in DG_Playground module","text":"","category":"section"},{"location":"function_index/#","page":"Function Index","title":"Function Index","text":"Modules = [DG_Playground]","category":"page"},{"location":"function_index/#DG_Playground.Field1D","page":"Function Index","title":"DG_Playground.Field1D","text":"Field1D(mesh)\n\nDescription\n\ninitialize Field1D struct\n\nArguments\n\nmesh: a mesh to compute on\n\nReturn Values:\n\nu : the field to be computed\nu̇: numerical solutions for the field\nflux: the numerical flux for the computation\n\n\n\n\n\n","category":"type"},{"location":"function_index/#DG_Playground.Mesh-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.Mesh","text":"mesh(K, n, xmin, xmax)\n\nDescription\n\nouter_constructor mesh struct\n\nArguments\n\nK: number of elements\nn: polynomial order\nxmin: lower bound\nxmax: upper bound\n\nReturn Values: x\n\nreturn grid values\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.build_operator-Tuple{Any,Mesh}","page":"Function Index","title":"DG_Playground.build_operator","text":"buildoperator(affineoperator!, 𝒢::Mesh; mass_matrix = false)\n\nDescription\n\nbuilds affine operator associated with operator\n\nComment\n\nWith non-homogenous boundary conditions becomes affine\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dmatrix-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.dmatrix","text":"dmatrix(x, α, β, N)\n\nDescription\n\nReturn the differentiation matrix of order N at the values x\nAllocates too much memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second paramater for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nD: the differentiation matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobiGL-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.jacobiGL","text":"jacobiGL(α, β, N)\n\nDescription\n\nGuass Labatto quadrature points for the Jacobi Polynomial (α,β)\nThe quadrature weights are computed as well (but not returned)\n\nArguments\n\nα, β: Jacobi polynomial descriptors\nN:    order of quadrature\n\nReturn: x\n\nx: quadrature points  | array of size N+1\n\nExamples\n\njulia> x = jacobiGL(0, 0, 4)\n5-element Array{Float64,1}:\n -1.0\n -0.6546536707079759\n  4.440892098500626e-16\n  0.6546536707079771\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.lift1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.lift1D","text":"lift1D(V, y) for computing fluxes helps compute a surface integral of a quantity note that the parentheses are necessary to prevent too much multiplcation the E function takes the surface integrals are presents it with respect to the full space inside an element the entire operator represents how fluxes flow into the interior of an element\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.vandermonde-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.vandermonde","text":"vandermonde(x, α, β, N)\n\nDescription\n\nReturn vandermonde matrix of order N at the values x\nAllocates a little bit of memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nv: vandermonde matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.external_params","page":"Function Index","title":"DG_Playground.external_params","text":"external_params{T,S}\n\nDescription\n\nstruct for external params needed for advection\n\nMembers\n\nfirst is velocity\nsecond is value for α\n\n\n\n\n\n","category":"type"},{"location":"function_index/#DG_Playground.buildmaps1D-NTuple{8,Any}","page":"Function Index","title":"DG_Playground.buildmaps1D","text":"buildmaps1D(K, nGL, nFP, nFaces, fmask, EtoE, EtoF, x)\n\nDescription\n\nconnectivity matrices for element to elements and elements to face\n\nArguments\n\nK: number of elements\nnGL: number of points within an element (polynomial degree + 1)\nnFP: 1\nnFaces: 2\nfmask: an element by element mask to extract edge values\nEtoE: element to element connectivity\nEtoF: element to face connectivity\nx: Guass lobatto points\n\nReturn Values: vmapM, vmapP, vmapB, mapB, mapI, mapO, vmapI, vmapO\n\nvmapM: vertex indices, (used for interior u values)\nvmapP: vertex indices, (used for exterior u values)\nvmapB: vertex indices, corresponding to boundaries\nmapB: use to extract vmapB from vmapM\nmapI: Index of left boundary condition\nmapO: Index of right boundary condition\n\nExample | uses ../utils.jl\n\nK = 3 n = 3; α = 0; β = 0; xmin = 0; xmax = 2π; nGL = n + 1 nFP = 1 nFaces = 2\n\nr = jacobiGL(α, β, n)\n\nVX, EtoV = unimesh1D(xmin, xmax, K) EtoE, EtoF = connect1D(EtoV) x = gridvalues1D(VX, EtoV, r) fx = edgevalues1D(r,x)\n\nvmapM, vmapP, vmapB, mapB, mapI, mapO, vmapI, vmapO = buildmaps1D(K, nGL, nFP, nFaces, fmask, EtoE, EtoF, x)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.connect1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.connect1D","text":"connect1D(EtoV)\n\nDescription\n\nbuilds global connectivity arrays for 1D\n\nArguments\n\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nReturn Values: EtoE, EtoF\n\nEtoE: element to element connectivity\nEtoF: element to face connectivity\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.djacobi-Tuple{Any,Any,Any,Int64}","page":"Function Index","title":"DG_Playground.djacobi","text":"djacobi(x, α, β, n)\n\nDescription\n\nEvaluates the derivative of the jacobi polynomial at the point x\n\nArguments\n\nx: point at which you will evaluate the derivative of the jacobi polynomial\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nn : order\n\nReturn\n\ny: the derivative of the of the Jacobi polynomial\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dropϵzeros!-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.dropϵzeros!","text":"dropϵzeros!(sparseMatrix, drop_criteria)\n\nDescription\n\nDrops machine zeros in sparse matrix\n\nArguments\n\nA: a sparse matrix\ndrop_criteria: criteria for dropping entries\n\nreturn\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dropϵzeros!-Tuple{Any}","page":"Function Index","title":"DG_Playground.dropϵzeros!","text":"dropϵzeros!(sparseMatrix)\n\nDescription\n\nDrops machine zeros in sparse matrix\n\nArguments\n\n!A: a sparse matrix\n\nreturn\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.dvandermonde-NTuple{4,Any}","page":"Function Index","title":"DG_Playground.dvandermonde","text":"dvandermonde(x, α, β, N)\n\nDescription\n\nReturn the gradient of the vandermonde matrix of order N at the values x\nAllocates a little bit of memory\n\nArguments\n\nx: points at which to evaluate the Jacobi polynomials\nα: first parameter for Jacobi polynomials\nβ: second paramater for Jacobi polynomials\nN: maximum order of Jacobi polynomial to include\n\nReturn Values\n\nvr: gradient of vandermonde matrix\n\nExample\n\nSee LegendreTests.jl\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.edgevalues1D-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.edgevalues1D","text":"edgevalues1D(fmask, x)\n\nDescription\n\ncalculates edge values\n\nArguments\n\nfmask: face mask for GL edges\n\nx:  physical coordinates of solution on each element\n\nReturn Values: x\n\nfx: face values of x\n\nExample | ../utils.jl\n\nr = jacobiGL(0, 0, 4) x = gridvalues1D(VX, EtoV, r) fmask = fmask1D(r)[1] fx = edgevalues1D(fmask,x)\n\nthe locations of the edges in element 1 is fx[:, 1]\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.fmask1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.fmask1D","text":"facemask1D(r)\n\nDescription\n\ncreates face mask\n\nArguments\n\nr: GL points\n\nReturn Values: x\n\nfmask1: standard facemask\nfmask2: alternate form\n\nExample | ../utils.jl\n\nr = jacobiGL(0, 0, 4) fmask = fmask1D(r)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.geometric_factors-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.geometric_factors","text":"geometric_factors(x, Dʳ)\n\nDescription\n\ncomputes the geometric factors for local mappings of 1D elements\n\nArguments\n\nx: physical coordinates of solution for each element\n\nDʳ:\n\nReturn Values: rx, J\n\nrx: inverse jacobian\n\nJ: jacobian (in 1D a scalar)\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.gridvalues1D-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.gridvalues1D","text":"gridvalues1D(xmin, xmax, K)\n\nDescription\n\nGenerates physical gridpoints with each element\n\nArguments\n\nVX: vertex values | an Array of size K+1\n\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nr: LGL nodes in reference element | an array\n\nReturn Values: x\n\nx: physical coordinates of solution\n\nExample (uses ../utils.jl as well)\n\nxmin = 0 xmax = 2π K = 4\n\ncall functions\n\nVX, EtoV = unimesh1D(xmin, xmax, K) r = jacobiGL(0, 0, 4) x = gridvalues1D(VX, EtoV, r)\n\nx[:,1] is the physical coordinates within the first element\n\nfor plotting\n\nf(x) = sin(x) plot(x, f.(x))\n\nscatter(x,f.(x)) tends to work better\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobi-Tuple{Any,Any,Any,Int64}","page":"Function Index","title":"DG_Playground.jacobi","text":"jacobi(x, α, β, n)\n\nDescription\n\nEvaluates the jacobi polynomial at the point x\n\nArguments\n\nx: point at which you will evaluate the jacobi polynomial\nα: first parameter for Jacobi polynomials\nβ: second parameter for Jacobi polynomials\nn : order\n\nReturn\n\ny: the value of the of the Jacobi polynomial\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.jacobiGQ-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.jacobiGQ","text":"jacobiGQ(α, β, N)\n\nDescription\n\nGuass Quadrature points and weights for the Jacobi Polynomial (α,β)\n\nInput\n\nα, β: Jacobi polynomial descriptors N:    order of quadrature points\n\nReturn: x,w\n\nx: quadrature points | array of size N+1 w: quadrature weights | array of size N+1 #Example α = 0 β = 0 N = 4 x, w = jacobiGQ(α, β, N)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.lift1D_v2-Tuple{Any}","page":"Function Index","title":"DG_Playground.lift1D_v2","text":"lift1D_v2(V, y) for computing fluxes nodal form helps compute a surface integral of a quantity note that the parantheses are necessary to prevent too much multiplcation the E function takes the surface integrals are presents it with respect to the full space inside an element the entire operator represents how fluxes flow into the interior of an element\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.make_periodic1D!-Tuple{Any,Any}","page":"Function Index","title":"DG_Playground.make_periodic1D!","text":"make_periodic1D!(vmapP, u)\n\nDescription\n\nmakes the grid periodic by modifying vmapP.\nAssumes that the first node is connected to the last.\n\nArguments\n\nvmapP: exterior vertex map\nu: vertex vector\n\nReturn Values: none\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.normals1D-Tuple{Any}","page":"Function Index","title":"DG_Playground.normals1D","text":"normals1D(K)\n\nDescription\n\ncalculates face normals\n\nArguments\n\nK: number of elements\n\nReturn Values: normals\n\nnormals: face normals along each grid\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"function_index/#DG_Playground.unimesh1D-Tuple{Any,Any,Any}","page":"Function Index","title":"DG_Playground.unimesh1D","text":"unimesh1D(xmin, xmax, K)\n\nDescription\n\nGenerates a uniform 1D mesh\n\nArguments\n\nxmin: smallest value of array\nxmax: largest values of array\nK: number of elements in an array\n\nReturn Values: VX, EtoV\n\nVX: vertex values | an Array of size K+1\nEtoV: element to node connectivity | a Matrix of size Kx2\n\nExample\n\nxmin = -1 xmax =  1 K    =  4 VX, EtoV = unimesh1D(xmin, xmax, K)\n\n\n\n\n\n","category":"method"},{"location":"#DG_Playground-1","page":"Home","title":"DG_Playground","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A repository for quickly prototyping ideas ideas for the CLIMA project. The main objectives are to","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Test / develop relevant preconditioners\nCreate useful abstractions for timestepping and DG operators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The core DG algorithm being used here is based on the textbook by Hesthaven and Warburton.","category":"page"}]
}
